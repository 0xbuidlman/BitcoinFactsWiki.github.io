<!DOCTYPE html>
<html>
<head>

<meta charset="utf-8" />
<title>CVE-2012-3789</title>

<link rel="stylesheet" href="../style.css" type="text/css" />

<link rel="stylesheet" href="../local.css" type="text/css" />










</head>
<body>

<article class="page">

<section class="pageheader">
<header class="header">
<span>
<span class="parentlinks">

<a href="../">bitcoin</a>/ 

</span>
<span class="title">
CVE-2012-3789

</span>
</span>



</header>


<nav class="actions">
<ul>







<li><span class="createlink"><a href="/ikiwiki.cgi?from=CVE-2012-3789&amp;page=Talk&amp;do=create" rel="nofollow">?</a>Talk</span></li>


</ul>
</nav>








</section>

<div id="pagebody">

<section id="content" role="main">
<h2 id="Multiple_DoS_Vulnerabilties_in_Satoshi_Bitcoin_client">Multiple DoS Vulnerabilties in Satoshi Bitcoin client</h2>

<p>Private Release Date: 12-MAY-2012<br />
Public Release Date: 08-JAN-2013<br /></p>

<h3 id="Systems_Affected">Systems Affected</h3>

<hr />

<ul>
<li>Satoshi Bitcoin Client (Bitcoin-Qt, bitcoind)<br /></li>
<li>All Bitcoin clients that mimic Satoshi client behaviour related to orphan transactions<br /></li>
</ul>


<h3 id="Affected_Versions">Affected Versions</h3>

<hr />

<ul>
<li>Bitcoin version 0.5.3, released 14 March 2012<br /></li>
<li>Bitcoin version 0.5.3.1 released 16 March 2012<br /></li>
<li>Bitcoin version 0.6.0 released 30 March 2012<br /></li>
<li>Bitcoin version 0.6.1 released 4 May 2012<br /></li>
<li>Bitcoin version 0.6.2 released 8 May 2012<br /></li>
</ul>


<h3 id="Overview">Overview</h3>

<hr />

<p>This report contains information regarding two new vulnerabilities discovered in May-2012. The more severe one allows a
connected peer to hang the victim&#39;s client application in less than 20 minutes by sending a stream of specially
crafted transactions, as a denial-of-service attack.</p>

<h3 id="Background">Background</h3>

<hr />

<p>Each peer defines a transaction as &quot;Orphan&quot; if the transaction references a parent transaction (previous output) which is
neither part of a block in the current best chain, nor it is  in the in-memory transaction pool.
Before version 0.5.3 of Satoshi Bitcoin client, orphan transactions were stored in a temporary table in memory until the parent transactions could be located in a block or the parent transaction was forwarded by a peer.
The storage for ophan transaction was unlimited. This feature allowed an attacker to perform a DoS attack by sending transactions continuously until the victim&#39;s virtual memory was filled and the victim&#39;s operating system began trashing. This situation probably leads to the victim&#39;s computer or application to hang.
The time needed for this DoS attack varies depending on the link bandwidth between the attacker and the victim, and the victim&#39;s RAM size. For an average computer and Internet connection it takes approximately 12 hours.</p>

<p>The vulnerability was discovered by Sergio Demian Lerner and communicated to the Bitcoin.org development team, who developed and applied a patch (https://github.com/bitcoin/bitcoin/pull/911) that was incorporated in version 0.5.3.
The patch limits the number of orphan transactions that are stored in memory and randomly erases a previous stored transaction on the arrival of a new one, if the memory table becomes full.</p>

<p>Unfortunately the patch is ineffective and allows two new vectors of attack that are more severe than the original attack. The patched version still allows an attacker to fill the victim&#39;s memory with orphan transactions (see vulnerability 1) and it also allows an attacker to hang the victim&#39;s client application (see vulnerability 2) in less than 20 minutes.</p>

<h3 id="Vulnerability_1_Details">Vulnerability 1 Details</h3>

<hr />

<p>Orphan transactions are stored in the table mapOrphanTransactions. The patch limits the number of entries to 10000 (constant MAX_ORPHAN_TRANSACTIONS). This number is arbitrary, and the criteria for the selection of the constant is unknown. Because transactions are not limited in size, is easy to create an orphan transaction whose size reaches
1 megabyte. If the transaction is built with thousands of random inputs (prevouts which are unknown to the victim app) then also the table mapOrphanTransactionsByPrev can fill the entire RAM. Prevouts whose hash is chosen at random would make trashing worse since virtual memory page faults will become inevitable.</p>

<p>Suppose the attacker wants the victim to store 4 Gigabytes of data in virtual memory. Assume a 50 Kb/sec connection bandwidth.
Then the attack takes approximately 11 hours.</p>

<h3 id="Patching_vulnerability_1">Patching vulnerability 1</h3>

<hr />

<p>The application must limit the amount of memory used by tables mapOrphanTransactions and mapOrphanTransactionsByPrev, either by counting the number of bytes used or by limiting the maximum size of each orphan transaction.</p>

<p>Added note: Bitcoin version 0.6.3 and later only store orphan transactions whose size is less than 5000 byles. This limits the amount of memory that mapOrphanTransactions can consume, totalling no more than 50 Mbytes. Since the &quot;map&quot; data structure has a significant overhead when storing a single element, 5000 transactions that link to many random missing previns can force mapOrphanTransactionsByPrev to consume as high as 200 additional megabytes.</p>

<p>Some extra security provisions may be implemented:</p>

<ul>
<li>Prioritize orphan transactions that provide a proof of work per input (network protocol must be changed).</li>
<li>Limit the amount of transactions that each peer can send depending on the peer connection time  (older peers get more bandwidth)</li>
</ul>


<h3 id="Vulnerability_2_Details">Vulnerability 2 Details</h3>

<hr />

<p>Each time a transaction must be erased from mapOrphanTransactions, all references to parent transactions must be erased from the table mapOrphanTransactionsByPrev too (see EraseOrphanTx()). The method wrongly assumes that the number of
associations between a parent transaction and its potential childs is low, and so the code iterates through all pairs parent/child until the transaction to be erased is found. Code excerpt:</p>

<pre><code>BOOST_FOREACH(const CTxIn&amp; txin, tx.vin)
{
for (multimap&lt;uint256, CDataStream*&gt;::iterator mi = mapOrphanTransactionsByPrev.lower_bound(txin.prevout.hash);
mi != mapOrphanTransactionsByPrev.upper_bound(txin.prevout.hash);)
{
if ((*mi).second == pvMsg)
mapOrphanTransactionsByPrev.erase(mi++);
else
mi++;
}
}
</code></pre>

<p>Each reference to a previous transaction is specified by a prevout, which is a hash of the transaction and an index of the outpoint referred. An attacker can send 10000 transactions that whose inputs refer to the same parent transaction (same hash), but specifying different indexes. Index numbers can be chosen incrementally (from 1 to 1M) since indexes cannot be verified to be out of range for a (still unknown) parent transaction.</p>

<p>The attack is strengthened by the fact that client applications do not check for empty scripts in inputs, so each input size can be as low as 41 bytes. 11K transaction containing 100 fake inputs each is enough to hang a Satoshi client in an Intel Core 2 CPU 4300 running on a local testnet in less than a minute. If a connection of 50 Kb/sec is assumed, then the attack takes less than 20 minutes. Note that only one core of the CPU gets 100% of usage, because the client runs a single thread to process all messages from peers. Simulations were carried on on a local testnet, so the outcome of the attack on a real node (with plenty of peer connections) was not evaluated.</p>

<h3 id="Patching_vulnerability_2">Patching vulnerability 2</h3>

<hr />

<p>One possible change is to modify the mapOrphanTransactionsByPrev data structure from:</p>

<pre><code>multimap&lt;uint256, CDataStream*&gt; mapOrphanTransactionsByPrev;
</code></pre>

<p>to:</p>

<pre><code>map&lt;uint256, map&lt;uint256,CDataStream*&gt; &gt; mapOrphanTransactionsByPrev;
</code></pre>

<p>Example new EraseOrphanTx() method (not tested):</p>

<pre><code>void static EraseOrphanTx(uint256 hash)
{
if (!mapOrphanTransactions.count(hash))
return;
const CDataStream* pvMsg = mapOrphanTransactions&lt;a href=&quot;../Hash/&quot;&gt;hash&lt;/a&gt;;
CTransaction tx;
BOOST_FOREACH(const CTxIn&amp; txin, tx.vin)
{
mapOrphanTransactionsByPrev&lt;span class=&quot;createlink&quot;&gt;&lt;a href=&quot;/ikiwiki.cgi?from=CVE-2012-3789&amp;amp;do=create&amp;amp;page=txin.prevout.hash&quot; rel=&quot;nofollow&quot;&gt;?&lt;/a&gt;txin.prevout.hash&lt;/span&gt;.erase(hash);
}
mapOrphanTransactions.erase(hash);
}
</code></pre>

<p>Added note: Bitcoin version 0.6.3 and later includes this modification.</p>

<h3 id="Disclosure_Timeline">Disclosure Timeline</h3>

<hr />

<ul>
<li>2012-05-12 - Vulnerability reported to Gavin Andressen</li>
<li>2012-05-17 - Gavin Andressen patches ready for review</li>
<li>2012-06-20 - 0.6.3rc1 available for testing</li>
<li>2012-06-25 - Bitcoin version 0.6.3 released, fixing the vulnerabilities.</li>
<li>2013-01-08 - Vulnerability disclosure</li>
</ul>


<h3 id="Credit">Credit</h3>

<hr />

<p>This vulnerability was discovered by Sergio Demian Lerner, from Certimix.com, who also did
the vulnerability research and report editing for the public good.</p>

<h2 id="See_Also">See Also</h2>

<ul>
<li><a href="../Common_Vulnerabilities_and_Exposures/">Common Vulnerabilities and Exposures</a></li>
</ul>


</section>







</div>

<footer id="footer" class="pagefooter" role="contentinfo">

<nav id="pageinfo">






<nav id="backlinks">
Links:

<a href="../Common_Vulnerabilities_and_Exposures/">Common Vulnerabilities and Exposures</a>


</nav>


<div class="copyrightinfo">
Content is available under under <a href="https://creativecommons.org/licenses/by-sa/3.0/">CC by-sa</a>
</div>

<div class="pagedate">
Last edited <time datetime="2015-03-06T15:52:16Z">Fri 06 Mar 2015 03:52:16 PM Europe</time>
<!-- Created <time datetime="2013-01-08T17:53:10Z" pubdate="pubdate">Tue 08 Jan 2013 05:53:10 PM Europe</time> -->
</div>

</nav>


<!-- from bitcoin -->
</footer>
</article>

</body>
</html>
